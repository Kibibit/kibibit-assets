<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>X Person Card</title>
<style>
  :root{
    --bg:#fff; --fg:#0b0b0c; --muted:#6b7280; --hair:#e5e7eb; --link:#111;
    --chip:#f3f4f6;
  }
  [data-theme="dark"]{
    --bg:#0b0b0c; --fg:#f1f5f9; --muted:#94a3b8; --hair:#1f2937; --link:#e5e7eb; --chip:#111827;
  }
  html,body{margin:0; background:transparent; color:var(--fg); font:14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;}
  a{color:var(--link); text-decoration:none} a:hover{text-decoration:underline}
  .card{ max-width:520px; border:1px solid var(--hair); border-radius:12px; padding:14px; background:var(--bg); }
  .row{ display:flex; gap:12px; align-items:flex-start; }
  .avatar{ width:56px; height:56px; border-radius:50%; object-fit:cover; background:var(--hair); }
  .name{ font-weight:700; font-size:16px; }
  .handle{ color:var(--muted); }
  .bio{ margin:6px 0 10px; color:var(--fg) }
  .latest{ border-top:1px solid var(--hair); padding-top:10px; margin-top:10px; }
  .meta{ color:var(--muted); font-size:12px; margin-top:6px; }
  .actions{ margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
  .chip{ background:var(--chip); border:1px solid var(--hair); border-radius:999px; padding:6px 10px; font-weight:600; display:flex; align-items:center; }
  .chip svg, .chip img{ flex-shrink:0; }
  .loader{ color:var(--muted); padding:10px 0 }
  .compact .bio{ display:none }
  .compact .latest{ display:none }
  .kb-logo { height: 1.2em; margin-right: 0.5em; fill: var(--fg); }
</style>
</head>
<body>
<div id="app" class="card"><div class="loader">Loading…</div></div>
<script>
(async function(){
  const qs = new URLSearchParams(location.search);
  const user = (qs.get("u") || "openai").replace(/^@/,'');      // ?u=handle
  const theme = (qs.get("theme") || "light");                    // ?theme=dark|light
  const compact = qs.has("compact");                             // ?compact
  const refresh = Math.max(0, parseInt(qs.get("refresh")||"0",10)); // ?refresh=120
  const nitter = qs.get("nitter") || "https://nitter.net";       // override instance if needed
  const ttlSec = Math.max(30, parseInt(qs.get("ttl")||"",10) || 604800); // default 1 week
  const CACHE_NS = "xpcache_v1";
  const LRU_LIMIT = 10;

  document.documentElement.setAttribute("data-theme", theme);
  const app = document.getElementById("app");
  if (compact) app.classList.add("compact");

  // ---------- Cache (LRU + TTL) ----------
  const now = () => Date.now();
  const keyFor = (u, nbase) => `${CACHE_NS}:${nbase}:${u.toLowerCase()}`;
  const readJSON = (k) => { try { return JSON.parse(localStorage.getItem(k)||"null"); } catch { return null; } };
  const writeJSON = (k,v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };

  function touchLRU(k){
    const idxKey = `${CACHE_NS}:index`;
    const idx = readJSON(idxKey) || [];
    const filtered = idx.filter(x => x !== k);
    filtered.unshift(k);
    while (filtered.length > LRU_LIMIT) {
      const drop = filtered.pop();
      if (drop) localStorage.removeItem(drop);
    }
    writeJSON(idxKey, filtered);
  }
  function getCache(u, nbase){
    const k = keyFor(u, nbase);
    const entry = readJSON(k);
    if (!entry) return null;
    if ((now() - entry.ts) > ttlSec*1000) return null;
    touchLRU(k);
    return entry.data;
  }
  function setCache(u, nbase, data){
    const k = keyFor(u, nbase);
    writeJSON(k, { ts: now(), data });
    touchLRU(k);
  }

  // ---------- Fetch helpers ----------
  const prox = async (url) => {
    try {
      const r = await fetch("https://api.allorigins.win/raw?url=" + encodeURIComponent(url), {cache:"no-cache"});
      if (r.ok) return await r.text();
      throw 0;
    } catch {
      const r2 = await fetch("https://r.jina.ai/http://" + url.replace(/^https?:\/\//,''));
      if (!r2.ok) throw new Error("proxy fail");
      return await r2.text();
    }
  };

  function parseProfile(html, user){
    let display = user;
    const titleMatch = html.match(/<title>([^<]+) \/ /);
    if (titleMatch) display = titleMatch[1].trim();
    const bioMatch = html.match(/<div class="profile-bio">([\s\S]*?)<\/div>/);
    const bio = bioMatch ? bioMatch[1].replace(/<[^>]+>/g,'').trim() : "";
    return { display, bio };
  }

  function parseLatest(rss, user){
    const xml = new DOMParser().parseFromString(rss, "application/xml");
    const item = xml.querySelector("item");
    let postTitle = "", postLink = `https://x.com/${user}`, postISO = "";
    if (item){
      postTitle = item.querySelector("title")?.textContent || "";
      postLink  = item.querySelector("link")?.textContent || postLink;
      const pub = item.querySelector("pubDate")?.textContent;
      postISO  = pub ? new Date(pub).toISOString() : "";
    }
    return { postTitle, postLink, postISO };
  }

  function renderCard({display, user, bio, avatar, postTitle, postLink, postISO, profileURL}){
    const postDate = postISO ? new Date(postISO).toLocaleString() : "";
    app.innerHTML = `
      <div class="row">
        <img class="avatar" src="${avatar}" alt="${display} avatar" referrerpolicy="no-referrer">
        <div>
          <div class="name">${display}</div>
          <div class="handle">@${user}</div>
        </div>
      </div>
      <div class="bio">${bio || ""}</div>
      <div class="latest">
        <a href="${postLink}" target="_blank" rel="noopener">${postTitle || "View profile"}</a>
        ${postDate ? `<div class="meta">${postDate}</div>` : ""}
      </div>
      <div class="actions">
        <a class="chip follow" href="https://x.com/${user}" target="_blank" rel="noopener">
          <svg class="kb-logo" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>X</title>
            <path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/>
          </svg>
          Follow
        </a>
        <a class="chip" href="${profileURL}" target="_blank" rel="noopener">
          <img src="https://nitter.net/logo.png" class="kb-logo" alt="Nitter">
          Nitter
        </a>
      </div>
    `;
  }

  async function fetchFresh(user, nbase){
    const profileURL = `${nbase}/${user}`;
    const rssURL = `${nbase}/${user}/rss`;
    const [html, rss] = await Promise.all([prox(profileURL), prox(rssURL)]);
    const { display, bio } = parseProfile(html, user);
    const { postTitle, postLink, postISO } = parseLatest(rss, user);
    const avatar = `https://unavatar.io/twitter/${encodeURIComponent(user)}`;
    return { display, user, bio, avatar, postTitle, postLink, postISO, profileURL };
  }

  // Retry just the BIO (lighter) until we get a value, then update cache + DOM.
  async function retryBioUntilPresent(user, nbase, initialData){
    const profileURL = `${nbase}/${user}`;
    const MAX_ATTEMPTS = 6;              // ~ up to ~63s total with backoff
    let attempt = 0, delay = 1000;

    while (attempt < MAX_ATTEMPTS) {
      try {
        const html = await prox(profileURL);
        const { bio } = parseProfile(html, user);
        if (bio && bio.trim()) {
          const updated = { ...initialData, bio };
          setCache(user, nbase, updated);
          // Update only the bio section in the DOM (don’t rerender everything)
          const bioEl = app.querySelector('.bio');
          if (bioEl) bioEl.textContent = bio;
          return; // done
        }
      } catch (e) {
        // ignore and continue retrying
      }
      await new Promise(res => setTimeout(res, delay));
      delay = Math.min(delay * 2, 32000); // cap backoff
      attempt++;
    }
    // give up quietly if still empty
  }

  // ---------- Flow ----------
  const cached = getCache(user, nitter);
  if (cached){
    renderCard(cached);
  } else {
    app.innerHTML = `<div class="loader">Loading…</div>`;
  }

  try{
    const data = await fetchFresh(user, nitter);
    renderCard(data);
    setCache(user, nitter, data);

    // If bio missing/empty, retry in background until we get one, then update cache + DOM
    if (!data.bio || !data.bio.trim()) {
      retryBioUntilPresent(user, nitter, data);
    }
  }catch(e){
    if (!cached){
      app.innerHTML = `<div class="loader">Failed to load. Try again later.</div>`;
    }
    console.error(e);
  }

  if (refresh > 0){
    setInterval(async () => {
      if (document.hasFocus && document.hasFocus()){
        try{
          const data = await fetchFresh(user, nitter);
          renderCard(data);
          setCache(user, nitter, data);
          if (!data.bio || !data.bio.trim()) {
            retryBioUntilPresent(user, nitter, data);
          }
        }catch(e){ console.error(e); }
      }
    }, refresh * 1000);
  }
})();
</script>
</body>
</html>
