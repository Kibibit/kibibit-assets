<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>X Person Card</title>
<style>
  :root{
    --bg:#fff; --fg:#0b0b0c; --muted:#6b7280; --hair:#e5e7eb; --link:#111;
    --chip:#f3f4f6;
  }
  [data-theme="dark"]{
    --bg:#0b0b0c; --fg:#f1f5f9; --muted:#94a3b8; --hair:#1f2937; --link:#e5e7eb; --chip:#111827;
  }
  html,body{margin:0; background:transparent; color:var(--fg); font:14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;}
  a{color:var(--link); text-decoration:none} a:hover{text-decoration:underline}
  .card{ max-width:520px; border:1px solid var(--hair); border-radius:12px; padding:14px; background:var(--bg); }
  .row{ display:flex; gap:12px; align-items:flex-start; }
  .avatar{ width:56px; height:56px; border-radius:50%; object-fit:cover; background:var(--hair); }
  .name{ font-weight:700; font-size:16px; }
  .handle{ color:var(--muted); }
  .bio{ margin:6px 0 10px; color:var(--fg) }
  .latest{ border-top:1px solid var(--hair); padding-top:10px; margin-top:10px; }
  .meta{ color:var(--muted); font-size:12px; margin-top:6px; }
  .actions{ margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
  .chip{ background:var(--chip); border:1px solid var(--hair); border-radius:999px; padding:6px 10px; font-weight:600; display:flex; align-items:center; }
  .chip svg, .chip img{ flex-shrink:0; }
  .loader{ color:var(--muted); padding:10px 0 }
  .compact .bio{ display:none }
  .compact .latest{ display:none }
  .kb-logo { height: 1.2em; margin-right: 0.5em; fill: var(--fg); }
</style>
</head>
<body>
<div id="app" class="card"><div class="loader">Loading…</div></div>
<script>
(async function(){
  const NITTERS = [
    "https://nitter.net",
    "https://nitter.privacydev.net",
    "https://nitter.pufe.org",
    "https://nitter.poast.org",
    "https://nitter.fdn.fr",
    "https://nitter.cz"
  ];
  const LAST_OK_KEY = "xpc_last_nitter";

  const qs = new URLSearchParams(location.search);
  const user = (qs.get("u") || "openai").replace(/^@/,'');
  const theme = (qs.get("theme") || "light");
  const compact = qs.has("compact");
  const refresh = Math.max(0, parseInt(qs.get("refresh")||"0",10));
  const ttlSec = Math.max(30, parseInt(qs.get("ttl")||"",10) || 604800);

  document.documentElement.setAttribute("data-theme", theme);
  const app = document.getElementById("app");
  if (compact) app.classList.add("compact");

  // Proxy fetch with fallback
  async function fetchViaProxies(url, timeoutMs=9000){
    const withTimeout = (p) => Promise.race([
      p,
      new Promise((_,rej)=>setTimeout(()=>rej(new Error("timeout")), timeoutMs))
    ]);
    const attempts = [
      () => fetch(`https://r.jina.ai/http://${url.replace(/^https?:\/\//,'')}`),
      () => fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`),
      () => fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`).then(r=>r.ok?r.json().then(j=>new Response(j.contents||"",{status:200})):r),
      () => fetch(`https://thingproxy.freeboard.io/fetch/${url}`)
    ];
    for (const tryFn of attempts) {
      try {
        const res = await withTimeout(tryFn());
        if (res.ok) return await res.text();
      } catch {}
    }
    throw new Error("All proxies failed");
  }

  async function pickNitterBase() {
    const override = qs.get("nitter");
    if (override) return override;
    const last = localStorage.getItem(LAST_OK_KEY);
    const list = last ? [last, ...NITTERS.filter(n=>n!==last)] : NITTERS;
    for (const base of list) {
      try {
        await fetchViaProxies(`${base}/about`, 5000);
        localStorage.setItem(LAST_OK_KEY, base);
        return base;
      } catch {}
    }
    return NITTERS[0];
  }

  function parseProfile(html, user){
    let display = user;
    const titleMatch = html.match(/<title>([^<]+) \/ /);
    if (titleMatch) display = titleMatch[1].trim();
    const bioMatch = html.match(/<div class="profile-bio">([\s\S]*?)<\/div>/);
    const bio = bioMatch ? bioMatch[1].replace(/<[^>]+>/g,'').trim() : "";
    return { display, bio };
  }
  function parseLatest(rss, user){
    const xml = new DOMParser().parseFromString(rss, "application/xml");
    const item = xml.querySelector("item");
    let postTitle = "", postLink = `https://x.com/${user}`, postISO = "";
    if (item){
      postTitle = item.querySelector("title")?.textContent || "";
      postLink  = item.querySelector("link")?.textContent || postLink;
      const pub = item.querySelector("pubDate")?.textContent;
      postISO  = pub ? new Date(pub).toISOString() : "";
    }
    return { postTitle, postLink, postISO };
  }
  function renderCard({display, user, bio, avatar, postTitle, postLink, postISO, profileURL}){
    const postDate = postISO ? new Date(postISO).toLocaleString() : "";
    app.innerHTML = `
      <div class="row">
        <img class="avatar" src="${avatar}" alt="${display} avatar" referrerpolicy="no-referrer">
        <div>
          <div class="name">${display}</div>
          <div class="handle">@${user}</div>
        </div>
      </div>
      <div class="bio">${bio || ""}</div>
      <div class="latest">
        <a href="${postLink}" target="_blank" rel="noopener">${postTitle || "View profile"}</a>
        ${postDate ? `<div class="meta">${postDate}</div>` : ""}
      </div>
      <div class="actions">
        <a class="chip follow" href="https://x.com/${user}" target="_blank" rel="noopener">
          <svg class="kb-logo" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>X</title>
            <path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/>
          </svg>
          Follow
        </a>
        <a class="chip" id="nitterLink" href="#" target="_blank" rel="noopener">
          <img src="https://nitter.net/logo.png" class="kb-logo" alt="Nitter">
          Nitter
        </a>
      </div>
    `;
  }

  async function fetchFresh(base){
    const profileURL = `${base}/${user}`;
    const rssURL = `${base}/${user}/rss`;
    const [html, rss] = await Promise.all([
      fetchViaProxies(profileURL),
      fetchViaProxies(rssURL)
    ]);
    const { display, bio } = parseProfile(html, user);
    const { postTitle, postLink, postISO } = parseLatest(rss, user);
    const avatar = `https://unavatar.io/twitter/${encodeURIComponent(user)}`;
    return { display, user, bio, avatar, postTitle, postLink, postISO, profileURL };
  }

  // Cache helpers
  const CACHE_NS = "xpcache_v1"; const LRU_LIMIT = 10;
  const now = ()=>Date.now();
  const keyFor = (u, nbase)=>`${CACHE_NS}:${nbase}:${u.toLowerCase()}`;
  const readJSON = (k)=>{ try{return JSON.parse(localStorage.getItem(k)||"null");}catch{return null;} };
  const writeJSON = (k,v)=>{ try{localStorage.setItem(k, JSON.stringify(v));}catch{} };
  function touchLRU(k){
    const idxKey = `${CACHE_NS}:index`;
    const idx = readJSON(idxKey) || [];
    const filtered = idx.filter(x=>x!==k); filtered.unshift(k);
    while (filtered.length>LRU_LIMIT){ const drop=filtered.pop(); if(drop) localStorage.removeItem(drop); }
    writeJSON(idxKey, filtered);
  }
  function getCache(u, nbase){
    const k = keyFor(u,nbase); const entry = readJSON(k);
    if(!entry) return null; if((now()-entry.ts) > ttlSec*1000) return null;
    touchLRU(k); return entry.data;
  }
  function setCache(u,nbase,data){
    const k=keyFor(u,nbase); writeJSON(k,{ts:now(), data}); touchLRU(k);
  }

  // flow
  const base = await pickNitterBase();
  const cached = getCache(user, base);
  if (cached) renderCard(cached); else app.innerHTML = `<div class="loader">Loading…</div>`;

  try{
    const data = await fetchFresh(base);
    renderCard(data);
    setCache(user, base, data);
    const linkEl = document.getElementById("nitterLink");
    if (linkEl) linkEl.href = data.profileURL;
  }catch(e){
    if (!cached) app.innerHTML = `<div class="loader" style="color:#b91c1c">Failed to load. Try again later.</div>`;
    console.error(e);
  }

  if (refresh > 0){
    setInterval(async ()=>{
      if (document.hasFocus && document.hasFocus()){
        try{
          const data = await fetchFresh(base);
          renderCard(data);
          setCache(user, base, data);
        }catch{}
      }
    }, refresh*1000);
  }
})();
</script>
</body>
</html>
